{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the sfizz wiki!</p>"},{"location":"#developer-notes","title":"Developer notes","text":"<ul> <li>Filters</li> <li>Resampling</li> <li>OBS builds</li> <li>Rolling out new versions</li> <li>To deprecate on next API ABI break</li> </ul>"},{"location":"#analysis","title":"Analysis","text":"<ul> <li>Effect routing</li> <li>Effects</li> <li>Curves</li> <li>EQ and filters</li> </ul>"},{"location":"#other","title":"Other","text":"<ul> <li>Ideas for longer term</li> <li>UI themes</li> </ul>"},{"location":"Curves/","title":"Curves","text":""},{"location":"Curves/#curve-formula","title":"Curve formula","text":"<p>0. linear, from 0 to 1</p> <p><code>f(x)=x</code> with <code>x=(CCval/127)</code></p> <p>1. bipolar, from -1 to 1 (useful for things such as tuning and panning, used by CC10 panning by default)</p> <p><code>f(x)=2*x-1</code> with <code>x=(CCval/127)</code></p> <p>2. linear inverted, from 1 to 0</p> <p><code>f(x)=1-x</code> with <code>x=(CCval/127)</code></p> <p>3. bipolar inverted, from 1 to -1</p> <p><code>f(x)=1-2*x</code> with <code>x=(CCval/127)</code></p> <p>4. concave (used for CC7 volume tracking and amp_veltrack)</p> <p><code>f(x)=x*x</code> with <code>x=(CCval/127)</code></p> <p>5. Xfin power curve</p> <p>Crossfading formula. It's like a typical pan formula for the right channel.</p> <p>ARIA's exact formula is <code>f(x)=pow(x, 0.5)</code> with <code>x=(CCval/127)</code></p> <p>Another candidate will be <code>sin(0.5*pi*x)</code>, for the pan formula already existing in Sfizz.</p> <p>6. Xfout power curve</p> <p>It's the opposite of Xfin power curve.</p> <p><code>f(x)=pow(1-x, 0.5)</code>,  with <code>x=(CCval/127)</code></p> <p>Alternative <code>cos(0.5*pi*x)</code></p>"},{"location":"Curves/#curve-numbers","title":"Curve numbers","text":"<p>When a <code>&lt;curve&gt;</code> element without an explicit <code>curve_index</code> is met, it takes the next available index starting from 1.</p> <p>Most times, software will reserve 6 slots for predefined curves. This will make the first user curve be 7, and it's a good idea to follow this as a convention.</p> <p>Example <pre><code>&lt;curve&gt; v000=0 v64=0.1 v127=1.0 // the curve at index 7\n&lt;curve&gt; v000=0 v64=0.1 v127=0.2 // the curve at index 8\n</code></pre></p>"},{"location":"Curves/#explicit-curve-index","title":"Explicit curve index","text":"<p>ARIA opcode <code>curve_index</code> permits to specify the explicit index.</p> <p>It can't seem to mix curves which are explicitly indexed and those which aren't.</p> <p>Explicitly-indexed curves after implicitly-indexed ones seem to be discarded by the loader, and vice-versa.</p>"},{"location":"Curves/#interpolation","title":"Interpolation","text":"<p>Both software are using linear interpolation to evaluate between the defined values. (verified)</p>"},{"location":"Curves/#bounds","title":"Bounds","text":"<ul> <li>In ARIA, the curve values are not bounded.</li> <li>In Cakewalk, the curve values are clamped in the domain [-1:+1].</li> </ul>"},{"location":"EQ-and-filters/","title":"EQ and filters","text":""},{"location":"EQ-and-filters/#cakewalk-peak-filters","title":"Cakewalk peak filters","text":"<p>This type of filter is activated by <code>fil_type=bpk_2p</code> (not <code>pkf_2p</code>). The peak gain is controlled by <code>resonance</code>, not <code>fil_gain</code> which is ARIA only.</p> <p>The peak is highest at <code>resonance=0</code> and attenuates for higher values. It is not yet studied how the <code>resonance</code> control and peak gain are related.</p>"},{"location":"Effect-routing/","title":"Effect routing","text":""},{"location":"Effect-routing/#bus-chaining","title":"Bus chaining","text":"<p>When multiple effects are in a bus, they are chained according to their order of appearance in SFZ.</p> <p>Example: chained effects in bus <pre><code>&lt;region&gt;\nsample=sinewave.wav\noscillator=on\nlokey=0\nhikey=127\neffect1=100\n\n&lt;effect&gt;\n//\ndirecttomain=0\nfx1tomain=100\n//\nbus=fx1\ntype=lofi\ndecim=100\ndecim_dry=0\ndecim_wet=100\n\n&lt;effect&gt;\nbus=fx1\ntype=fverb\nreverb_type=hall\nreverb_size=20\nreverb_tone=90\nreverb_dry=0\nreverb_wet=100\n</code></pre></p> <p>Example: chained effects in default chain <pre><code>&lt;region&gt;\nsample=sinewave.wav\noscillator=on\nlokey=0\nhikey=127\n\n&lt;effect&gt;\ntype=lofi\ndecim=100\ndecim_dry=0\ndecim_wet=100\n\n&lt;effect&gt;\ntype=fverb\nreverb_type=hall\nreverb_size=20\nreverb_tone=90\nreverb_dry=0\nreverb_wet=100\n</code></pre></p>"},{"location":"Effect-routing/#volumes-rxp","title":"Volumes (RXP)","text":"<ul> <li><code>effect1</code>: range 0%-100%, gain linear</li> <li><code>fx1tomain</code>: range 0%-100%, gain linear</li> <li><code>apan_dry</code>: range 0.0-1.0, gain linear</li> </ul>"},{"location":"Effect-routing/#analysis-1-rxp-single","title":"Analysis 1: RXP single","text":"<p>Synth: RXP</p> <p>SFZ template <pre><code>&lt;region&gt;\nsample=sinewave.wav\noscillator=on\neffect1=100\n\n&lt;effect&gt;\nbus=fx1\nfx1tomain=100\ntype=fverb\nreverb_type=hall\nreverb_size=20\nreverb_tone=90\nreverb_input=100\nreverb_dry=80\nreverb_wet=50\n</code></pre></p> <code>effect1</code> <code>bus</code> <code>fx1tomain</code> <code>reverb_input</code> Result Effect is heard (high volume) Omit Omit Omit Effect is heard (moderate volume) Omit Omit Effect is not heard Omit Effect is not heard Omit Effect is heard (high volume) Omit Effect is not heard Set to <code>fx2</code> Effect is not heard Set to <code>fx2</code> Set opcode to <code>fx2tomain</code> Effect is not heard Set opcode to <code>effect2</code> Set to <code>fx2</code> Set opcode to <code>fx2tomain</code> Effect is heard (high volume) Set opcode to <code>effect2</code> Omit Set opcode to <code>fx2tomain</code> Effect is heard (high volume) Set opcode to <code>effect2</code> Set to <code>fx1</code> Set opcode to <code>fx2tomain</code> Effect is not heard Any value Does not change anything Set opcode to <code>fx1tomix</code> Effect is heard (high volume) <p>Note: the all-omitted case is listed as moderate volume, the explicit case is high volume. It's because the latter mixes in another path of the dry signal (see next table below). This other path is neutralized when setting <code>directtomain=0</code>.  </p> <ul> <li>With <code>reverb_dry</code> to 0</li> </ul> <code>effect1</code> <code>bus</code> <code>fx1tomain</code> <code>reverb_input</code> Other Result Hear a mix of reverb sound and dry sound Omit Omit Omit Hear the reverb sound only add <code>directtomain=0</code> in <code>&lt;effect&gt;</code> Hear the reverb sound only"},{"location":"Effects/","title":"Effects","text":""},{"location":"Effects/#disto","title":"Disto","text":"<p>Rough approximation <code>cutoff = 440*2**((disto_tone*1.45-69)/12)</code></p> <p>Consider using the same formula as reverb below.</p>"},{"location":"Effects/#reverb","title":"Reverb","text":"<ul> <li><code>reverb_tone</code> 0-100 is the cutoff of a low pass filter</li> </ul> <p>The cutoff is analyzed by playing a sound in 2 instances, one with reverb_tone=100 and varying the tone of the other. Compute Y(z)/X(z) of the two spectrums and identify the -3dB point of the magnitude.</p> <p>The result is approximately <code>21+(0.01*reverb_tone)*108</code> expressed in midi pitch units.</p>"},{"location":"Effects/#automatic-pannner","title":"Automatic pannner","text":"<p>This is the automatic panner.</p> <p>Not exactly like the reference, more info in comments. (the depth control)</p> <pre><code>/**\n   Auto-panner\n\n   Frequency: same as `apan_freq`\n   Phase offset: same as `apan_phase`\n\n   Other:\n     - `apan_waveform`: LFO wave number (cf. `lfoN_wave`)\n     - `apan_depth`:\n          0 to disable, &gt;0 to enable (reference)\n          jpc: in this implementation, depth is allowed 0-100% granularity\n               to make it more meaningful\n\n   Note:\n     Reference uses a linear pan function.\n     Below, logarithmic is provided but it's commented.\n */\n\nimport(\"stdfaust.lib\");\n\nf = hslider(\"[1] Frequency [unit:Hz]\", 5.0, 0.01, 5.0, 0.01);\no = hslider(\"[2] Phase offset [unit:deg]\", 180.0, 0.0, 360.0, 1.0) : *(1.0/360.0);\nd = hslider(\"[3] Depth [unit:%]\", 50, 0, 100, 1) : *(0.01);\n\nautopan = *(panL(lfo01)), *(panR(lfo01))\nwith {\n  // any chosen waveform with output in domain [0:1]\n  calcLfo = triangle;\n\n  // output of the overall LFO, which modulates left and right exactly opposite\n  // it's the difference of 2 sub-LFO with a phase offset between them\n  lfoDD = d*(calcLfo(phase1)-calcLfo(phase2)); // outputs [-d:+d]\n  lfo01 = 0.5*(lfoDD+1.0); // outputs [0:1]\n\n  // running phase of 2 synced LFO with fixed offset\n  phase1 = os.lf_sawpos(f);\n  phase2 = wrap(phase1+o);\n\n  // ordinary stereo pan function (+3dB)\n  //panL(x) = cos(x*(ma.PI/2.0))*sqrt(2.0);\n  //panR(x) = sin(x*(ma.PI/2.0))*sqrt(2.0);\n\n  // linear stereo pan function\n  panL(x) = 2.*(1.-x);\n  panR(x) = 2.*(x);\n\n  triangle(p) = 1.-abs(2.*p-1.);\n  wrap(x) = x-int(x);\n};\n\n/* Test */\nprocess = autopan;\n// process = os.osci(110.0) : *(g) &lt;: (_, _) : autopan with {\n//   g = hslider(\"[4] Gain adjust\", 0.4, 0.1, 1.0, 0.01);\n// };\n</code></pre>"},{"location":"Effects/#bit-reduction","title":"Bit reduction","text":"<p>Matched <code>bitred</code> effect with 0-100 control range. Implementation below is naive, it needs antialiasing.</p> <p>Note: reference seems using a transition function to reduce aliasing between jumps from a quantization step to another.</p> <p>PolyBLEP: http://www.martin-finke.de/blog/articles/audio-plugins-018-polyblep-oscillator/</p> <pre><code>import(\"stdfaust.lib\");\n\namount = hslider(\"Amount\", 90, 0, 100, 1);\noversampling = 1;//fconstant(int gOversampling, &lt;math.h&gt;);\n\nbitred = *(steps) : roundToInt : /(steps) : hpf1p(20.0/oversampling) with {\n  roundToInt(x) = ba.if(x&lt;0, ma.neg(a), a) with { a = int(abs(x)); };\n  steps = 5.+(1.-amount*0.01)*512;\n};\n\nhpf1p(f) = fi.iir((0.5*(1.+p),-0.5*(1+p)),(0.-p)) with {\n  p = exp(-2.*ma.PI*f/ma.SR);\n};\n\n/* Test */\nprocess = os.osci(110.0/oversampling) : *(0.15) : bitred &lt;: (_, _);\n</code></pre> <p>Figure: reference effect 99% on 110Hz sine wave (green), implementation with hiir oversampling 2x (red). The tiny peak between steps suggests a use of transition function (like polyBLEP)</p> <p></p>"},{"location":"Effects/#decimation","title":"Decimation","text":"<p>Matched by exponential fit on the target sampling frequency, in 0-100 range.</p> <p>Same remarks apply as for <code>bitred</code> regarding polyBLEP, it's the same.</p> <pre><code>import(\"stdfaust.lib\");\n\namount = hslider(\"Amount\", 99, 0, 100, 1);\n\ndecim(x) = y : hpf1p(20.0) letrec {\n  'y = ba.if(p+(f/ma.SR)&gt;1.0, x, y);\n  'p = wrap(p+(f/ma.SR)); // the position 0-1\n}\nwith {\n  // exponential curve fit\n  a=5.729950e+04; b=-6.776081e-02; c=180;\n  f=a*exp(amount*b)+c;\n};\n\nhpf1p(f) = fi.iir((0.5*(1.+p),-0.5*(1+p)),(0.-p)) with {\n  p = exp(-2.*ma.PI*f/ma.SR);\n};\n\nwrap(x) = x-int(x);\n\n/* Test */\nprocess = os.osci(110.0) : *(0.15) : decim &lt;: (_, _);\n</code></pre>"},{"location":"Effects/#phaser","title":"Phaser","text":"<p>Not complete, only frequency range was analyzed. Filter has not been matched, feedback not yet analyzed. See notes in comments.</p> <pre><code>/*\nDual-notch Phaser, with linear cutoff control by LFO\n\nNote:\n  `phaser_stages`: number of stages. Cascade this function as many times as\n                   needed to produce the effect.\n  `phaser_waveform`: wave number (same as LFO)\n  `phaser_freq`: frequency of LFO which modulates the notches\n  `phaser_depth`: manipulates the 2 ranges of cutoff for the notches\n  `phaser_feedback`: TODO, implemented in model below but not measured\n  `phaser_phase[_oncc]`: TODO, assumed to be the phase 0-1 of LFO?\n*/\n\nimport(\"stdfaust.lib\");\n\nphaser = (+:notch1:notch2) ~ *(feedback) with {\n  depth = hslider(\"[1] Depth [unit:%]\", 50, 0, 100, 1);\n  lfoFreq = hslider(\"[2] LFO frequency [unit:Hz]\", 1.0, 0.0, 10.0, 0.01);\n\n  feedback = 0.0; // TODO determine `phaser_feedback` in the domain 0-100\n\n  lfo = os.lf_triangle(lfoFreq); // set any LFO waveform `phaser_waveform`\n\n  cutoffDepth1 = 31*depth;\n  cutoffMax1 = 3100.0;\n  cutoffCenter1 = 1600.0;\n\n  cutoffDepth2 = 155*depth;\n  cutoffMax2 = 13400.0;\n  cutoffCenter2 = 8300.0;\n\n  //widthAdjust = hslider(\"[3] Width adjust\", 0.5, 0.1, 10.0, 0.01);\n  widthAdjust = 0.5; // arbitrary pick, not checked\n\n  notchWidth1 = widthAdjust*cutoffDepth1;\n  notchWidth2 = widthAdjust*cutoffDepth2;\n\n  notchFreq1 = max(0,min(cutoffMax1,cutoffCenter1+lfo*cutoffDepth1));\n  notchFreq2 = max(0,min(cutoffMax2,cutoffCenter2+lfo*cutoffDepth2));\n\n  // filter pick arbitrary, could use also 1-pole allpass\n  notch1 = fi.notchw(notchWidth1, notchFreq1);\n  notch2 = fi.notchw(notchWidth2, notchFreq2);\n};\n\n/* Test */\nprocess = no.noise : *(0.15) : phaser;\n// process = phaser, phaser;\n</code></pre>"},{"location":"Filters/","title":"Filters","text":"<p>The filter design of sfizz is made after the models listed in SFZ specification. This design is compared against other established sampler software for verification.</p> <p>Filter reference: - https://sfzformat.com/opcodes/fil_type - https://sfzformat.com/opcodes/fil2_type</p>"},{"location":"Filters/#comparison-protocol","title":"Comparison protocol","text":"<p>For comparison, one can implement a SFZ using a <code>*noise</code> generator input, and observe the spectrum of the output.</p> <p>For an equivalence to this noise generator, one can compile a white noise generator of 1/4 amplitude. <pre><code>import(\"stdfaust.lib\");\nprocess = no.noise : *(0.25);\n</code></pre></p> <p>SFZ Example <pre><code>&lt;region&gt;\nsample=*noise\nlokey=0\nhikey=127\ncutoff=1000.0\nfil_type=lpf_2p\nfil_gain=0.0\nresonance=10.0\n</code></pre></p>"},{"location":"Filters/#the-biquad","title":"The biquad","text":"<p>The filters of 2, 4 or 6 poles kind are provided as biquad filters. A biquad is an IIR filter of the second order. 4-pole and 6-pole are obtained by cascading.</p> <p>The transfer function of the generic biquad is:</p> <p><code>H(z) = (b0 + b1*z^-1 + b2 * z^-2) / (a0 + a1 * z^-1 + a2 * z^-2)</code></p> <p>From this formula, the response is computed by substituting <code>z</code> for <code>exp(2*pi*j*fc/fs)</code>. The polar form of the result are the filter's amplitude and phase response.</p> <p>When <code>H(z)</code> is substituted with <code>Y(z) / X(z)</code>, and then this identity applied to pass from z-domain to time domain: <code>(A*X(z)*z^-N)</code> \u2192 <code>(A*x[n-N])</code></p> <p>It's the implementable Direct Form I equation:</p> <p><code>y[n] = (1/a0) * (b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2])</code></p> <p>Then, <code>a0</code> is factored into the equation to save an instruction in the computation:</p> <p><code>y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2] - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]</code></p> <p>It's the normalized form which is needed to use this filter in faust function <code>fi.iir</code>.</p>"},{"location":"Filters/#the-rbj-biquad","title":"The RBJ biquad","text":"<p>The most frequently used biquad kind is RBJ, named after initials of the author.</p> <p>It has a set of formulas for calculating coefficient for various kinds of responses.</p> <p>We select this filter for our implementation, because it matches near perfectly in the comparisons.</p> <p>It's available in faust in <code>maxmsp.lib</code>. Only in late or developer versions, this library was relicensed permissively, so instead it's copied in our source tree with the appropriate license mention. (as <code>rbj.lib</code>)</p> <p>Relevant discussions and PR: - https://github.com/sfztools/sfizz/issues/30</p>"},{"location":"Filters/#implementation","title":"Implementation","text":"<p>The implementation of the filters is subject to following prerequisites: - have controls which map to the documented opcodes - have ability to modulate frequency and resonance and fast rate - have stability, particularly in presence of important modulation</p> <p>We have a source <code>sfz_filters.dsp</code> written in faust language, an entry point to the filters.</p> <p>Faust is a specialized programming language which is able to generated optimized DSP code, in some aspects which are not sometimes possible in a non-specialized language.</p> <p>For instance, Faust is aware of some notions of variability, and adapt code generation and optimization accordingly. It can be defined like this: - constant: a value which never varies - a-rate: a value which updates at the audio rate, once per frame - k-rate: a value which updates at the control rate, once per <code>process</code> call</p> <p>When you have a filter which can modulate dynamically its response, there is potentially expensive computation involved. For instance, formulas of RBJ biquads involve trigonometry.</p> <p>To make modulation efficient as much as possible, this computation must be avoided at a-rate, but rather be made at k-rate.</p> <p>For this reason, we define out filter controls as parameters, as in the sliders of a hypothetical UI, and not signals. It's how to implement k-rate update. (even if no UI, faust calls it \"sliders\") <pre><code>cutoff = hslider(\"[01] Cutoff [unit:Hz] [scale:log]\", 440.0, 50.0, 10000.0, 1.0);\nQ = vslider(\"[02] Resonance [unit:dB]\", 0.0, 0.0, 40.0, 0.1) : ba.db2linear;\n</code></pre></p> <p>Our filter corresponding to each type has a naming convention starting with \"sfz\". As an example, the 2-pole lowpass is the function <code>sfzLpf2p</code>. It is 1-in, 1-out.</p>"},{"location":"Filters/#generation","title":"Generation","text":"<p>When filter functions are implemented, we generate all with a script since there exist a high quantity of them.</p> <p>See <code>scripts/generate_filters.sh</code>.</p> <p>The output is a file of <code>.cxx</code> extension for each. It's a special extension because it's not listed in CMake sources, rather all filters are included by a single implementation file. It permits also to inline them into their caller.</p> <p>The following faust options are used which are notable: - <code>-pn</code>: sets the name of the function to generate from <code>sfz_filters.dsp</code>, in this case the name of our filter function as noted in the convention above - <code>-cn</code>: sets the class name of generated C++ - <code>-double</code>: indicates to perform internal computations in double precision, which is found to be necessary for numeric stability - <code>-inpl</code>: allow to process the buffers in place; from what I can tell, it doesn't have performance impact.</p> <p>If you want to use a <code>faust</code> Docker image, you have to update the scripts to replace the line that calls <code>faust $FAUSTARGS ...</code> with <code>docker run -v $PWD:/faust faust:latest $FAUSTARGS ...</code>.</p> <p>On 2020-02-20, the version of <code>faust</code> used was <code>2.20.2</code> -- alot of 2 and 0 but it's not on purpose...</p>"},{"location":"Filters/#smoothing","title":"Smoothing","text":"<p>When the filter is modulated, we need a form of smoothing to apply, such that a modulation never applies a too brutal change which produces a discontinuity, destabilizing the filter.</p> <p>The smoothing function is a single-pole lowpass filter. Defined in <code>sfz_filters.dsp</code>, it's the function <code>smoothCoefs</code>.</p> <p>Handling this problem, there is one special consideration to consider: - if smoothing is applied to parameters Fc and Q, they will be varying at a-rate, and also the filter computation will also become a-rate, regardless that Fc and Q controls are k-rate, killing efficiency. - the solution is to apply smoothing to the individual coefficients <code>bN</code> and <code>aN</code>; since biquads are normalized, hence eliminates coefficient <code>a0</code>, there is generally need for 5 smooth filters (<code>b0</code>, <code>b1</code>, <code>b2</code>, <code>a1</code>, <code>a2</code>). In some RBJ filter types, there are some coefficients which are constant or equal to another, in this case faust will be able to eliminate and simplify as needed, so it needs less smooth filters than general case.</p> <p>Note that in Faust, the smoothing starts from for all parameters and as such it can cause a strange transient effect at the beginning of the filter. To handle this in the least hacky way, there is a boolean value in the Faust filters that deactivate the smoothing. The idea is to deactivate the smoothing, process a single empty sample with the proper parameter values, and then reactivate the smoothing. The parameters are now set to their initial values and processing can continue with the original smoothing function. In the wrapper, the <code>prepare</code> function call does this.</p> <p>Technically, the smoothing is a 1-pole IIR filter with a time constant <code>tau</code> set at 1ms. </p> <p>Relevant discussions and PR: - https://github.com/sfztools/sfizz/pull/70 - https://github.com/sfztools/sfizz/pull/64</p>"},{"location":"Filters/#filter-wrapper","title":"Filter wrapper","text":"<p>There exists a filter wrapper class written for multi-mode. This is found in <code>SfzFilters.h</code>.</p> <p>This is what is special regarding this wrapper: - the type of filter is selected through a choice of enumerated constants; - all filter objects are instantiated in this, but only one used based on value of type; - when there is a change of type, the memory of the new filter is cleared to zero, to avoid any glitches; theoretically a type change may cause discontinuity, but not in SFZ, since filter type is always fixed. - when the filter is not subject to modulations, the function call <code>process</code> is optimal. - when is is modulated, invoke <code>processModulated</code>. In this case, the filter updates will occur at a fixed interval <code>N</code> frames, to limit the frequency of updates. It's a latency-performance compromise. <code>N</code> is defined as <code>kFilterControlInterval</code> in the file <code>SfzFilterDefs.h</code>.</p>"},{"location":"Filters/#relation-of-controls-to-sfz-opcodes","title":"Relation of controls to SFZ opcodes","text":"<ul> <li><code>cutoff</code>: it's the opcode <code>filN_cutoff</code> (Hz)</li> <li><code>q</code>: it's the opcode <code>filN_resonance</code> (dB)</li> <li><code>pksh</code>: it's the opcode <code>filN_gain</code> (dB)</li> </ul>"},{"location":"Ideas-for-longer-term/","title":"Ideas for longer term","text":""},{"location":"Ideas-for-longer-term/#synthesis","title":"Synthesis","text":"<ul> <li> <p> Oscillator mode with FM &amp; Ringmod</p> </li> <li> <p> Virtual analog filters with non-linearities</p> </li> <li> <p> 2D Wavetable</p> </li> <li> <p> Wavetable oscillator from formula</p> </li> <li>eg: <code>sample=\"sin(pi * x)\"</code> Serum: sin(pi * -x)</li> <li>see: https://s3.amazonaws.com/decembercymatics/Serum_Manual.pdf (chapter 15: Formula Parser)</li> <li>discussion of Serum parser: https://www.kvraudio.com/forum/viewtopic.php?t=425973</li> <li>MIT parser library: http://www.partow.net/programming/exprtk/index.html</li> <li> <p>This suggestion is not to copy Serum, but rather enable custom wavetables to be constructed by Sfizz</p> </li> <li> <p> Granular</p> </li> <li> <p> Physical modelling (waveguide opcodes)</p> </li> <li> <p> Scala tuning support (load Scala file, set root note of scale &amp; mapped A4=Hertz value)</p> </li> <li>see http://www.huygens-fokker.org/scala/scl_format.html</li> <li> <p>default: (Equal Temperament, C, A4_MIDI_note_69=440hz)</p> </li> <li> <p> Analogue tuning of regions, (not Analogue modelling)</p> </li> <li>possibly <code>tune=analogue</code>? Or additional opcode.</li> </ul>"},{"location":"Ideas-for-longer-term/#modulation","title":"Modulation","text":"<ul> <li> <p> Arpeggiator</p> </li> <li> <p> Random walk LFO</p> </li> <li> <p>see https://www.muffwiggler.com/forum/viewtopic.php?t=10563</p> </li> <li> <p> LFO sync to host tempo</p> </li> <li> <p> LFO header for free running global LFOs</p> </li> </ul>"},{"location":"Ideas-for-longer-term/#sample-playback","title":"Sample Playback","text":"<ul> <li> <p> Global memory storage, allow multiple Sfizz instances to use same file pool</p> </li> <li> <p> Slice sample playback, from audio file with markers, useful for beat slicing, or concatenated sample libs. eg:</p> </li> </ul> <p><pre><code>&lt;region&gt;\nsample=mysample.wav\nslice=1\n</code></pre> - Possibly allow custom map for samples without markers?<code>slice_map=sampleslices.csv</code></p> <ul> <li> <p> Allow sfizz to load samples into RAM, instead of streaming, possibly <code>hint_ram</code> or as per Sforzando ARIA.</p> </li> <li> <p> Load multi-channel samples, and allow selecting stereo/mono channel per region</p> </li> </ul>"},{"location":"Ideas-for-longer-term/#effects","title":"Effects","text":"<ul> <li> <p> Standard effect set</p> </li> <li> <p> Signal flow arrangements   (cf. <code>dsp_order</code>)</p> </li> <li> <p> Effects per region / voice</p> </li> </ul>"},{"location":"Ideas-for-longer-term/#routing","title":"Routing","text":"<ul> <li> <p> Flexible routing : allow regions to be routed to separate sends</p> </li> <li> <p> Multi-channel output</p> </li> </ul>"},{"location":"Ideas-for-longer-term/#expressivity","title":"Expressivity","text":"<ul> <li> Metalanguage to write SFZ more easily, with less repetition.   Consider some ideas from CamelAudio Alchemy.</li> <li>edit several properties of an item with indenting syntax</li> <li>load data from CSV files</li> </ul>"},{"location":"Ideas-for-longer-term/#intruments","title":"Intruments","text":"<ul> <li> Import other existing sample libraries</li> </ul>"},{"location":"Ideas-for-longer-term/#midi-standards","title":"MIDI Standards","text":"<ul> <li> MPE</li> <li> MIDI 2.0</li> </ul>"},{"location":"Ideas-for-longer-term/#community","title":"Community","text":"<ul> <li> Sfizz Cloud integration</li> <li>similar to Blender Cloud membership, allow download of sample sets and tutorials</li> </ul>"},{"location":"OBS-builds/","title":"Open Build Service","text":"<p>Links to current build channels: - stable: https://build.opensuse.org/package/show/home:sfztools:sfizz/sfizz - develop: https://build.opensuse.org/package/show/home:sfztools:sfizz:develop/sfizz</p>"},{"location":"OBS-builds/#maintaining-the-builds","title":"Maintaining the builds","text":"<p>There are package builds by distribution which are organized as follows:</p> <ul> <li>RPM-style distribution: build steps in <code>sfizz.spec</code></li> <li>Deb-style distribution: build steps in <code>debian.rules</code>, metadata in other files <code>debian.*</code> and <code>sfizz.dsc</code></li> <li>Arch-style distribution: build steps in <code>PKGBUILD</code></li> </ul> <p>This organization is mostly explained in the OBS user manual.</p> <p>Depend on the target distribution, the package is splitted into multiple subpackages. - RPM: <code>sfizz</code>, <code>libsfizz0</code>, <code>libsfizz0-devel</code> - DEB: <code>sfizz</code>, <code>libsfizz0</code>, <code>libsfizz0-dev</code></p> <p>The <code>sfizz</code> package contains the LV2 and JACK programs. They are statically linked, so they do not have a dependency to <code>libsfizz0</code>.</p> <p>From OBS documentation, it's not clarified how to make Debian package splits. This is accomplished by specifying multiple <code>Package</code> entries in <code>debian.control</code>, and listing them again in the <code>Binary</code> field of <code>sfizz.dsc</code>.</p>"},{"location":"OBS-builds/#the-service","title":"The service","text":"<p>The OBS packages contain a <code>_service</code> file at the root.</p> <p>The goal of this file is to tell the builder to perform a series of operations before starting to build. The purpose can be to download the remote source archive, or to set the version of the package which is built.</p> <ul> <li>tar_scm: This clones the git repo and packs the result into a tarball, which makes it a source file of the build.    (this service is marked obsolete, but some target platforms don't allow the newer, so it's kept back on purpose)</li> <li>recompress: Applies compression on the created tarball to turn it into <code>tar.gz</code> or other</li> <li>set_version: Sets version in the package build files. The version number can be explicit, otherwise it can be created based on the git revision.</li> <li>download_url: Download a source file based on URL, and keep it in cache.</li> <li>verify_file: Apply a check based on hash to the downloaded file.</li> </ul> <p>Note: when committing, I can be required to install some OBS services on the local machine. At least on Arch, they are available in AUR as packages <code>obs-service-*</code>.</p>"},{"location":"OBS-builds/#updating-the-develop-channel","title":"Updating the develop channel","text":"<p>The develop channel is triggered by a Github webhook on push. It's fully automatic, and does not need update.</p>"},{"location":"OBS-builds/#updating-the-stable-channel","title":"Updating the stable channel","text":"<p>The stable channel contains a <code>_service</code> file that applies a version number automatically into the build files. To update, it's only needed to edit the <code>_service</code> file and none other.</p> <p>This is the example service of <code>sfizz 0.3.0</code>. To update it's just needed to change the version <code>0.3.0</code> everywhere and update the file checksum.</p> <pre><code>&lt;services&gt;\n  &lt;service name=\"set_version\"&gt;\n    &lt;param name=\"version\"&gt;0.3.0&lt;/param&gt;\n  &lt;/service&gt;\n  &lt;service name=\"download_url\"&gt;\n    &lt;param name=\"protocol\"&gt;https&lt;/param&gt;\n    &lt;param name=\"host\"&gt;github.com&lt;/param&gt;\n    &lt;param name=\"path\"&gt;sfztools/sfizz/releases/download/0.3.0/sfizz-0.3.0-src.tar.gz&lt;/param&gt;\n  &lt;/service&gt;\n  &lt;service name=\"verify_file\"&gt;\n    &lt;param name=\"file\"&gt;_service:download_url:sfizz-0.3.0-src.tar.gz&lt;/param&gt;\n    &lt;param name=\"verifier\"&gt;sha256&lt;/param&gt;\n    &lt;param name=\"checksum\"&gt;3ba24c1ca468391b6d2b209c712ea0d5032b7aeaf977f271d06681ce207d95bb&lt;/param&gt;\n  &lt;/service&gt;\n&lt;/services&gt;\n</code></pre>"},{"location":"Resampling/","title":"Resampling","text":""},{"location":"Resampling/#sinc-interpolation","title":"Sinc interpolation","text":"<p>The <code>sample_quality</code> settings from 3 to 10 are interpolations based on the windowed sinc method.</p> <p>https://ccrma.stanford.edu/~jos/lumped/Windowed_Sinc_Interpolation.html</p> <p>In the RGC sfz software, we have a number of quality settings available from a drop-down menu. These sinc settings are labelled: 08 12 16 24 36 48 60 72 One can easily guess that these designate a number of points. The numbers are multiples of 4, which makes them practical for SIMD processing.</p> <p>For implementation purposes, we want to precompute the sinc function in a large table. A window must be applied to the windowed sinc, in order to squash the edges. A Kaiser window is most appropriate, which permits to keep aliasing ripples under a determined amplitude threshold. It has a parameter <code>Beta</code>, permitting to establish a compromise: the higher <code>Beta</code>, the lower is the alias magnitude, but the selectivity of the \"brick wall\" filter worsens near the cutoff point.</p> <p>At first it seems an alright choice of <code>Beta</code> may be from about 6 to 10, as table size increases from 8 to 72.</p> <p>Tool for plotting frequency responses of sinc interpolators dynamically, when size and <code>Beta</code> are varied, based on the <code>deip.pdf</code> paper.</p>"},{"location":"Rolling-out-new-versions/","title":"Rolling out new versions","text":"<p>This assumes you have a clean clone of the Github repository.</p> <p>The process is as follows: 1. Update the versions where they need to be. This can include     - The CMake version numbers in <code>./CMakeLists.txt</code>     - The LV2 version number in <code>./cmake/LV2Config.cmake</code> if there was changes to the LV2 ports and addition/removal of options that affect the ABI of the plugin (not the library!)     - The VST version number if there was changes to the internal VST state format     - Check for missing or wrong <code>@since</code> version numbers in Doxygen comments. It's possible to use e.g. <code>git diff x.y.z HEAD -- src/sfizz.hpp</code> to compare the public API files. 2. Merge develop in master and tag; use the version number as a tag message <pre><code>git checkout master\ngit merge develop\ngit tag -a x.y.z\ngit push origin master\ngit push origin x.y.z\n</code></pre> 3. Let CI run 4. In case of deployment problems, correct things that need to be. If there are new changes, remerge master in develop <pre><code>git checkout develop\ngit merge master\n</code></pre> 5. Update and commit the next release version on develop (see 2) 6. Once tag/release is made, increment the library version to distinguish this new stable/release with future development builds.</p> <p>from LV2 documentation:</p> <p>if a change is made in the development version in source control, the micro version MUST be incremented (to an odd number) to distinguish this modified version from the previous release.</p>"},{"location":"To-deprecate-on-next-API-ABI-break/","title":"To deprecate on next API ABI break","text":"<ul> <li>The API is inconsistent between C++ and C; the <code>renderBlock</code> method in C++ uses <code>numOutputs</code> as the number of stereo channels, whereas the equivalent C method actually uses the number of mono channels. The order of parameters is also inconsistent.</li> </ul>"},{"location":"UI-themes/","title":"UI themes","text":"<p>Unlike the <code>image</code> opcode and the (future planned) XML UI, sfizz themes are internal to the player. They appears as XML files inside a directory where the name of the directory is the theme name. This because it makes it possible to include other custom resources other than the xml definition. These directories resides inside the <code>Themes</code> directory, located alongside with the other plugin resources. The file name is fixed to <code>theme.xml</code>, and currently it appears like the following.\\ The main <code>sfizz-theme</code> tag contains the attributes <code>author</code> and the sfizz <code>version</code> in which the theme was introduced, so that if in the future the scheme will change, we can bump the version, and it will not be retro-compatible.\\ Currently the theme(s) supports only colors and palettes.\\ Palettes are referred as <code>normal</code> for the usual color scheme and <code>inverted</code>, used for main bar which has a different contrast.\\ All colors are referred to the current layout components' colors.</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;sfizz-theme author=\"redtide\" version=\"1.0.1\"&gt;\n&lt;color name=\"frameBackground\"&gt;#121212&lt;/color&gt;\n&lt;palette name=\"normal\"&gt;\n&lt;color name=\"boxBackground\"&gt;#1d1d1d&lt;/color&gt;\n&lt;color name=\"text\"&gt;#e3e3e3&lt;/color&gt;\n&lt;color name=\"inactiveText\"&gt;#a2a2a2&lt;/color&gt;\n&lt;color name=\"highlightedText\"&gt;#e9e9e9&lt;/color&gt;\n&lt;color name=\"titleBoxText\"&gt;#e3e3e3&lt;/color&gt;\n&lt;color name=\"titleBoxBackground\"&gt;#2d2d2d&lt;/color&gt;\n&lt;color name=\"valueText\"&gt;#e3e3e3&lt;/color&gt;\n&lt;color name=\"valueBackground\"&gt;#121212&lt;/color&gt;\n&lt;color name=\"icon\"&gt;#e3e3e3&lt;/color&gt;\n&lt;color name=\"iconHighlight\"&gt;#ff6000&lt;/color&gt;\n&lt;color name=\"knobActiveTrack\"&gt;#006b0b&lt;/color&gt;\n&lt;color name=\"knobInactiveTrack\"&gt;#6f6f6f&lt;/color&gt;\n&lt;color name=\"knobLineIndicator\"&gt;#ffffff&lt;/color&gt;\n&lt;color name=\"knobText\"&gt;#ffffff&lt;/color&gt;\n&lt;color name=\"knobLabelText\"&gt;#ffffff&lt;/color&gt;\n&lt;color name=\"knobLabelBackground\"&gt;#006b0b&lt;/color&gt;\n&lt;/palette&gt;\n&lt;palette name=\"inverted\"&gt;\n&lt;color name=\"boxBackground\"&gt;#2d2d2d&lt;/color&gt;\n&lt;color name=\"text\"&gt;#9e9e9e&lt;/color&gt;\n&lt;color name=\"inactiveText\"&gt;#a2a2a2&lt;/color&gt;\n&lt;color name=\"highlightedText\"&gt;#e9e9e9&lt;/color&gt;\n&lt;color name=\"titleBoxText\"&gt;#9e9e9e&lt;/color&gt;\n&lt;color name=\"titleBoxBackground\"&gt;#2d2d2d&lt;/color&gt;\n&lt;color name=\"valueText\"&gt;#9e9e9e&lt;/color&gt;\n&lt;color name=\"valueBackground\"&gt;#121212&lt;/color&gt;\n&lt;color name=\"icon\"&gt;#9e9e9e&lt;/color&gt;\n&lt;color name=\"iconHighlight\"&gt;#ff6000&lt;/color&gt;\n&lt;color name=\"knobActiveTrack\"&gt;#006b0b&lt;/color&gt;\n&lt;color name=\"knobInactiveTrack\"&gt;#6f6f6f&lt;/color&gt;\n&lt;color name=\"knobLineIndicator\"&gt;#ffffff&lt;/color&gt;\n&lt;color name=\"knobText\"&gt;#ffffff&lt;/color&gt;\n&lt;color name=\"knobLabelText\"&gt;#ffffff&lt;/color&gt;\n&lt;color name=\"knobLabelBackground\"&gt;#006b0b&lt;/color&gt;\n&lt;/palette&gt;\n&lt;/sfizz-theme&gt;\n</code></pre>"}]}